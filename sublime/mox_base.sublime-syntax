%YAML 1.2
---
version: 2
scope: source.mox
# file_extensions: [mox]

# This base syntax is intented for sketches and experimentation. It supports
# basics like comments, delimiters, numeric literals, and string literals,
# without being overly specialized.
#
# TODO: invalid/illegal scoping for numbers immediately following a dot,
# except in numeric literals.

variables:
  comment_delim: ;
  comment_fence: '({{comment_delim}}{2,})(?!{{comment_delim}})'

  string_backtick_delim: '`'
  string_backtick_fence: '({{string_backtick_delim}}+)(?!{{string_backtick_delim}})'

  string_double_delim: '"'
  string_double_fence: '({{string_double_delim}}+)(?!{{string_double_delim}})'

  delim_chars: '\s\{\}\[\]\(\)'
  oper_chars: '\~\!\@\#\$\%\^\&\*\:\<\>\?\/\\\|\=\+\-'
  ident_chars: \w
  int_bin: '[0-1][0-1_]*'
  int_oct: '[0-7][0-7_]*'
  int_dec: '[0-9][0-9_]*'
  int_hex: '[0-9a-f][0-9a-f_]*'
  md_heading: ((#+)\s*\S.*){{eol}}
  dot: \.
  eol: (?:\n|$)

  # Almost any sequence of these characters is a symbol.
  # However, anything that begins with `-?\d` must be
  # a valid numeric literal.
  sym_chars: '{{dot}}{{sym_segment_chars}}'
  sym: '{{sym_break_begin}}[{{sym_chars}}]+{{sym_break_end}}'

  sym_segment_chars: '{{ident_chars}}{{oper_chars}}'

  sym_break_begin: (?<![{{sym_chars}}])(?!-?\d)
  sym_break_end: (?![{{sym_chars}}])

  sym_segment_break_begin: (?<![{{sym_segment_chars}}])
  sym_segment_break_end: (?![{{sym_segment_chars}}])

  sym_segment: '{{sym_segment_break_begin}}[{{sym_segment_chars}}]+{{sym_segment_break_end}}'
  sym_unqual: '{{sym_break_begin}}[{{sym_segment_chars}}]+{{sym_break_end}}'
  ident_unqual: '{{sym_break_begin}}[{{ident_chars}}]+{{sym_break_end}}'
  oper_unqual: '{{sym_break_begin}}[{{oper_chars}}]+{{sym_break_end}}'

contexts:
  # Misc common utils.

  now-pop:
    - match: ''
      pop: 1

  nonblank-pop:
    - match: (?=\S)
      pop: 1

  req-delim-pop:
    - match: '[^{{dot}}{{delim_chars}}]+'
      scope: invalid.illegal.jisp
      pop: 1
    - include: now-pop

  # Actual syntax.

  prototype:
    - include: comment-match

  comment-match:
    - include: comment-block-match

  comment-block-match:
    - match: '{{comment_fence}}'
      scope: comment.block.mox punctuation.definition.comment.begin.mox
      push: [req-delim-pop, comment-block-meta, comment-block-pop]

  comment-block-pop:
    - meta_include_prototype: false
    - match: \1
      scope: comment.block.mox punctuation.definition.comment.end.mox
      pop: 1
    - include: comment-heading-match

  comment-block-meta:
    - meta_content_scope: comment.block.mox
    - include: now-pop

  # TODO: make this work in single-liner block comments.
  comment-heading-match:
    - match: '^\s*((#+)\s+\S.*)(?:{{eol}})'
      captures:
        1: markup.heading.mox
        2: punctuation.definition.heading.begin.mox

  main:
    - include: any

  any:
    - match: (?=\S)
      push: expr-pop

  expr-pop:
    - include: expr-base-pop

  expr-base-pop:
    - include: delim-pop
    - include: str-pop
    - include: num-pop
    - include: sym-pop
    - include: dot-pop

  delim-pop:
    - include: paren-pop
    - include: bracket-pop
    - include: brace-pop

  paren-pop:
    - match: \)
      scope: punctuation.section.parens.end.mox invalid.illegal.mox
      pop: false
    - match: \(
      scope: punctuation.section.parens.begin.mox
      set: paren-inner-pop

  paren-inner-pop:
    - meta_scope: meta.parens.mox
    - include: paren-end-pop
    - include: any

  paren-end-pop:
    - match: \)
      scope: punctuation.section.parens.end.mox
      pop: 1

  bracket-pop:
    - match: \]
      scope: punctuation.section.brackets.end.mox invalid.illegal.mox
      pop: false
    - match: \[
      scope: punctuation.section.brackets.begin.mox
      set: bracket-inner-pop

  bracket-inner-pop:
    - meta_scope: meta.brackets.mox
    - include: bracket-end-pop
    - include: any

  bracket-end-pop:
    - match: \]
      scope: punctuation.section.brackets.end.mox
      pop: 1

  brace-pop:
    - match: \}
      scope: punctuation.section.braces.end.mox invalid.illegal.mox
      pop: false
    - match: \{
      scope: punctuation.section.braces.begin.mox
      set: brace-inner-pop

  brace-inner-pop:
    - meta_scope: meta.braces.mox
    - include: brace-end-pop
    - include: any

  brace-end-pop:
    - match: \}
      scope: punctuation.section.braces.end.mox
      pop: 1

  str-pop:
    - include: str-backtick-pop
    - include: str-double-pop

  str-backtick-pop:
    - include: str-backtick-empty-pop
    - include: str-backtick-fenced-pop

  # This special case matches two quotes with no other content, treating it as
  # an empty string. This means we won't be treating it as an opening fence.
  str-backtick-empty-pop:
    - match: '({{string_backtick_delim}})({{string_backtick_delim}})(?!{{string_backtick_delim}})'
      scope: string.quoted.other.mox
      captures:
        1: punctuation.definition.string.begin.mox
        2: punctuation.definition.string.end.mox
      set: req-delim-pop

  str-backtick-fenced-pop:
    - match: '{{string_backtick_fence}}'
      scope: string.quoted.other.mox punctuation.definition.string.begin.mox
      set: [req-delim-pop, str-backtick-meta, str-backtick-inner-pop]

  # Backtick strings are "raw": no escape characters.
  # Double strings support escape characters.
  str-backtick-inner-pop:
    - meta_include_prototype: false
    - match: \1
      scope: punctuation.definition.string.end.mox
      pop: 1

  str-backtick-meta:
    - meta_content_scope: string.quoted.other.mox
    - include: now-pop

  str-double-pop:
    - include: str-double-empty-pop
    - include: str-double-fenced-pop

  # This special case matches two quotes with no other content, treating it as
  # an empty string. This means we won't be treating it as an opening fence.
  str-double-empty-pop:
    - match: '({{string_double_delim}})({{string_double_delim}})(?!{{string_double_delim}})'
      scope: string.quoted.other.mox
      captures:
        1: punctuation.definition.string.begin.mox
        2: punctuation.definition.string.end.mox
      set: req-delim-pop

  str-double-fenced-pop:
    - match: '{{string_double_fence}}'
      scope: string.quoted.double.mox punctuation.definition.string.begin.mox
      set: [req-delim-pop, str-double-meta, str-double-inner-pop]

  str-double-inner-pop:
    - meta_include_prototype: false
    - include: str-escape-match
    - match: \1
      scope: punctuation.definition.string.end.mox
      pop: 1

  str-double-meta:
    - meta_content_scope: string.quoted.double.mox
    - include: now-pop

  str-escape-match:
    - match: \\(?:.|\n)
      scope: constant.character.escape.mox

  num-pop:
    - include: num-bin-pop
    - include: num-oct-pop
    - include: num-hex-pop
    - include: num-dec-pop

  num-bin-pop:
    - match: (-)?(0b)(?:{{int_bin}}(?:(\.){{int_bin}})?)?
      scope: constant.numeric.binary.mox
      captures:
        1: keyword.operator.arithmetic.jisp
        2: punctuation.definition.numeric.binary.mox
        3: punctuation.separator.mox
      set: req-delim-pop

  num-oct-pop:
    - match: (-)?(0o)(?:{{int_oct}}(?:(\.){{int_oct}})?)?
      scope: constant.numeric.octal.mox
      captures:
        1: keyword.operator.arithmetic.jisp
        2: punctuation.definition.numeric.octal.mox
        3: punctuation.separator.mox
      set: req-delim-pop

  num-hex-pop:
    - match: (-)?(0h)(?:{{int_hex}}(?:(\.){{int_hex}})?)?
      scope: constant.numeric.hexadecimal.mox
      captures:
        1: keyword.operator.arithmetic.jisp
        2: punctuation.definition.numeric.hexadecimal.mox
        3: punctuation.separator.mox
      set: req-delim-pop

  num-dec-pop:
    - match: (-)?{{int_dec}}(?:(\.){{int_dec}})?
      scope: constant.numeric.decimal.mox
      captures:
        1: keyword.operator.arithmetic.jisp
        2: punctuation.separator.mox
      set: req-delim-pop

  sym-pop:
    - match: '{{sym_segment_break_begin}}_{{sym_segment_break_end}}'
      scope: variable.language.blank.mox
      pop: 1
    - match: '(?<![{{ident_chars}}])[{{oper_chars}}]+(?![{{ident_chars}}])'
      scope: keyword.operator.mox
      pop: 1
    - match: '[{{sym_segment_chars}}]+'
      scope: variable.other.mox
      pop: 1

  dot-pop:
    - match: '{{dot}}'
      scope: punctuation.accessor.mox
      pop: 1
