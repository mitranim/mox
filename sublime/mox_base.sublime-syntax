%YAML 1.2
---
version: 2
scope: source.mox
# file_extensions: [mox]

# This base syntax is intented for sketches and experimentation. It supports
# basics like comments, delimiters, numeric literals, and string literals,
# without being overly specialized.

variables:
  comment_delim: ;
  comment_fence: '({{comment_delim}}{2,})(?!{{comment_delim}})'
  md_heading: ((#+)\s*\S.*){{eol}}

  string_backtick_delim: '`'
  string_backtick_fence: '({{string_backtick_delim}}+)(?!{{string_backtick_delim}})'

  string_double_delim: '"'
  string_double_fence: '({{string_double_delim}}+)(?!{{string_double_delim}})'

  int_bin: '[0-1][0-1_]*'
  int_oct: '[0-7][0-7_]*'
  int_dec: '[0-9][0-9_]*'
  int_hex: '[0-9a-f][0-9a-f_]*'

  delim_chars: '\s\{\}\[\]\(\)'
  oper_chars: '\~\!\@\#\$\%\^\&\*\:\<\>\?\/\\\|\=\+\-'
  ident_chars: \w
  ident_begin_char: '[A-Za-z_]'

  ident_begin: '\b'
  ident_end: '\b'
  oper_begin: (?<![{{oper_chars}}])
  oper_end: (?![{{oper_chars}}])

  ident: '{{ident_begin}}{{ident_begin_char}}[{{ident_chars}}]*{{ident_end}}'
  oper: '{{oper_begin}}[{{oper_chars}}]+{{oper_end}}'
  sym: '(?:{{ident}}|{{oper}})'

  dot: \.
  eol: (?:\n|$)

contexts:
  # Misc common utils.

  now-pop:
    - match: ''
      pop: 1

  nonblank-pop:
    - match: (?=\S)
      pop: 1

  # Actual syntax.

  prototype:
    - include: comment-match

  comment-match:
    - include: comment-block-match

  comment-block-match:
    - match: '{{comment_fence}}'
      scope: comment.block.mox punctuation.definition.comment.begin.mox
      push: [comment-block-meta, comment-block-pop]

  comment-block-pop:
    - meta_include_prototype: false
    - match: \1
      scope: comment.block.mox punctuation.definition.comment.end.mox
      pop: 1
    - include: comment-heading-match

  comment-block-meta:
    - meta_content_scope: comment.block.mox
    - include: now-pop

  # TODO: make this work in single-liner block comments.
  comment-heading-match:
    - match: '^\s*((#+)\s+\S.*)(?:{{eol}})'
      captures:
        1: markup.heading.mox
        2: punctuation.definition.heading.begin.mox

  main:
    - include: any

  any:
    - match: (?=\S)
      push: expr-pop

  expr-pop:
    - include: expr-base-pop

  expr-base-pop:
    - include: delim-pop
    - include: str-pop
    - include: num-pop
    - include: sym-pop
    - include: dot-pop

  delim-pop:
    - include: paren-pop
    - include: bracket-pop
    - include: brace-pop

  paren-pop:
    - match: \)
      scope: punctuation.section.parens.end.mox invalid.illegal.mox
      pop: false
    - match: \(
      scope: punctuation.section.parens.begin.mox
      set: paren-inner-pop

  paren-inner-pop:
    - meta_scope: meta.parens.mox
    - include: paren-end-pop
    - include: any

  paren-end-pop:
    - match: \)
      scope: punctuation.section.parens.end.mox
      pop: 1

  bracket-pop:
    - match: \]
      scope: punctuation.section.brackets.end.mox invalid.illegal.mox
      pop: false
    - match: \[
      scope: punctuation.section.brackets.begin.mox
      set: bracket-inner-pop

  bracket-inner-pop:
    - meta_scope: meta.brackets.mox
    - include: bracket-end-pop
    - include: any

  bracket-end-pop:
    - match: \]
      scope: punctuation.section.brackets.end.mox
      pop: 1

  brace-pop:
    - match: \}
      scope: punctuation.section.braces.end.mox invalid.illegal.mox
      pop: false
    - match: \{
      scope: punctuation.section.braces.begin.mox
      set: brace-inner-pop

  brace-inner-pop:
    - meta_scope: meta.braces.mox
    - include: brace-end-pop
    - include: any

  brace-end-pop:
    - match: \}
      scope: punctuation.section.braces.end.mox
      pop: 1

  str-pop:
    - include: str-backtick-pop
    - include: str-double-pop

  str-backtick-pop:
    - include: str-backtick-empty-pop
    - include: str-backtick-fenced-pop

  # This special case matches two quotes with no other content, treating it as
  # an empty string. This means we won't be treating it as an opening fence.
  str-backtick-empty-pop:
    - match: '({{string_backtick_delim}})({{string_backtick_delim}})(?!{{string_backtick_delim}})'
      scope: string.quoted.other.mox
      captures:
        1: punctuation.definition.string.begin.mox
        2: punctuation.definition.string.end.mox
      pop: 1

  str-backtick-fenced-pop:
    - match: '{{string_backtick_fence}}'
      scope: string.quoted.other.mox punctuation.definition.string.begin.mox
      set: [str-backtick-meta, str-backtick-inner-pop]

  # Backtick strings are "raw": no escape characters.
  # Double strings support escape characters.
  str-backtick-inner-pop:
    - meta_include_prototype: false
    - match: \1
      scope: punctuation.definition.string.end.mox
      pop: 1

  str-backtick-meta:
    - meta_content_scope: string.quoted.other.mox
    - include: now-pop

  str-double-pop:
    - include: str-double-empty-pop
    - include: str-double-fenced-pop

  # This special case matches two quotes with no other content, treating it as
  # an empty string. This means we won't be treating it as an opening fence.
  str-double-empty-pop:
    - match: '({{string_double_delim}})({{string_double_delim}})(?!{{string_double_delim}})'
      scope: string.quoted.other.mox
      captures:
        1: punctuation.definition.string.begin.mox
        2: punctuation.definition.string.end.mox
      pop: 1

  str-double-fenced-pop:
    - match: '{{string_double_fence}}'
      scope: string.quoted.double.mox punctuation.definition.string.begin.mox
      set: [str-double-meta, str-double-inner-pop]

  str-double-inner-pop:
    - meta_include_prototype: false
    - include: str-escape-match
    - match: \1
      scope: punctuation.definition.string.end.mox
      pop: 1

  str-double-meta:
    - meta_content_scope: string.quoted.double.mox
    - include: now-pop

  str-escape-match:
    - match: \\(?:.|\n)
      scope: constant.character.escape.mox

  num-pop:
    - include: num-bin-pop
    - include: num-oct-pop
    - include: num-hex-pop
    - include: num-dec-pop

  num-bin-pop:
    - match: ([+-])?(0b)(?:{{int_bin}}(?:(\.){{int_bin}})?)?
      scope: constant.numeric.binary.mox
      captures:
        1: keyword.operator.arithmetic.jisp
        2: punctuation.definition.numeric.binary.mox
        3: punctuation.separator.mox
      set: num-delim-pop

  num-oct-pop:
    - match: ([+-])?(0o)(?:{{int_oct}}(?:(\.){{int_oct}})?)?
      scope: constant.numeric.octal.mox
      captures:
        1: keyword.operator.arithmetic.jisp
        2: punctuation.definition.numeric.octal.mox
        3: punctuation.separator.mox
      set: num-delim-pop

  num-hex-pop:
    - match: ([+-])?(0h)(?:{{int_hex}}(?:(\.){{int_hex}})?)?
      scope: constant.numeric.hexadecimal.mox
      captures:
        1: keyword.operator.arithmetic.jisp
        2: punctuation.definition.numeric.hexadecimal.mox
        3: punctuation.separator.mox
      set: num-delim-pop

  num-dec-pop:
    - match: ([+-])?{{int_dec}}(?:(\.){{int_dec}})?
      scope: constant.numeric.decimal.mox
      captures:
        1: keyword.operator.arithmetic.jisp
        2: punctuation.separator.mox
      set: num-delim-pop

  num-delim-pop:
    - match: '[A-Za-z]+'
      scope: invalid.illegal.mox
      pop: 1
    - match: ''
      pop: 1

  sym-pop:
    - match: '{{ident_begin}}_{{ident_end}}'
      scope: variable.language.blank.mox
      pop: 1
    # Every operator is a call, one way or another.
    - match: '{{oper}}'
      scope: keyword.operator.mox
      pop: 1
    - match: '{{sym}}'
      scope: variable.other.mox
      pop: 1

  dot-pop:
    - match: '{{dot}}'
      scope: punctuation.accessor.mox
      pop: 1
