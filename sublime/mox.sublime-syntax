%YAML 1.2
---
version: 2
extends: Packages/mox/mox_base.sublime-syntax
scope: source.mox
file_extensions: [mox]

# TODO:
# - Struct fields should have `variable.other.member.declaration.mox` in struct
#   declarations and regular `variable.other.member.mox` at usage sites.
# - Support destructuring in declarations.
# - In declarations, differentiate kinds: type / function / value.
#   - Needed for indexing types and functions declared in nested scopes.
# - In declaration positions, disallow operators (due to ambiguity).
# - In declaration positions, support strings-as-symbols (for disambiguation).
# - Put `meta.type` scopes into type literals.
# - Consider always scoping `X Y Z` symbols as parameters.

variables:
  line_start: '^\s*'
  sym_unqual: (?<!{{dot}}){{sym}}
  ident_unqual: (?<!{{dot}})[{{ident_chars}}]+(?![{{oper_chars}}])
  oper_unqual: (?<!{{dot}})[{{oper_chars}}]+(?![{{ident_chars}}])

contexts:
  main:
    - match: (?=\S)
      push: expr-pop

  sym-assign-pop:
    - match: '(_)\s+(=)(?=\s|$)'
      captures:
        1: variable.language.blank.mox
        2: keyword.operator.assignment.mox
      set: expr-pop
    # Known false positive: in `one. two = 123`,
    # `two` is scoped as declaration.
    - match: '({{sym}})\s+(=)(?=\s|$)'
      captures:
        1: variable.declaration.mox
        2: keyword.operator.assignment.mox
      set: expr-pop

  expr-pop:
    - match: ''
      set: [expr-postfix-join, expr-base-pop]

  expr-postfix-join:
    - match: (?={{dot}})
      set: expr-pop

    # An unqualified operator is binary.
    - match: '{{oper_unqual}}'
      scope: keyword.operator.mox
      set: expr-pop

    - match: (?=\S)
      pop: 1

  sym-pop:
    - meta_prepend: true
    - include: sym-dot-end-match
    - include: sym-const-pop
    - include: sym-assign-pop
    - include: sym-call-prefix-pop
    - include: sym-call-suffix-pop
    - include: sym-dot-match

  sym-dot-end-match:
    - match: '{{sym}}(?={{dot}}{{sym}})'
      scope: variable.other.mox
    - match: '{{sym}}(?={{dot}})'
      scope: variable.function.mox

  sym-const-pop:
    - match: '{{sym_begin}}(?:true|false|nil){{sym_end}}'
      scope: constant.language.mox
      pop: 1

  sym-call-suffix-pop:
    - match: ({{dot}})({{sym}})
      captures:
        1: punctuation.accessor.mox
        2: variable.function.mox
      pop: 1

  sym-dot-match:
    - match: '{{dot}}'
      scope: punctuation.accessor.mox

  brace-pop:
    - match: \}
      scope: punctuation.section.braces.end.mox invalid.illegal.mox
      pop: false
    - match: \{
      scope: punctuation.section.braces.begin.mox
      set: [brace-meta, brace-key-pop]

  brace-meta:
    - meta_scope: meta.braces.mox
    - include: now-pop

  brace-key-pop:
    - include: brace-end-pop
    - match: '{{sym}}'
      scope: variable.other.member.declaration.mox
      set: brace-val-pop
    - match: (?=\S)
      set: [brace-val-pop, brace-expr-pop2]

  brace-val-pop:
    - include: brace-end-pop
    - match: (?=\S)
      set: [brace-key-pop, expr-pop]

  brace-expr-pop2:
    - match: \}
      scope: punctuation.section.braces.end.mox
      pop: 2
    - match: (?=\S)
      set: expr-pop
