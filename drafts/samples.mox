;;
## Hello world

Traditional:
;;
main = fn.(
  log.`hello world!`
)

;; Two expressions. ;;
main = fn.(
  msg = `hello world!`
  log.(msg)
)

;;
## Fibonacci sequence

The function is defined below. This is how we call it:
;;
fib.42            ;; With a literal value. ;;
fib.(some_number) ;; With a named value. ;;

;;
Example definition.

Easiest to understand: a recursive version incompatible with tail-call
optimization. See below for a non-stack-overflowing version.
;;
fib = fn.(
  (X <= 1)
    ? X
    : fib.(X - 1) + fib.(X - 2)
)

;;
Procedural non-recursive version.
Translated from bot-generated Python.
Can probably be greatly simplified.
;;
fib = fn.(
  ;;
  `X` refers to the first input.
  This proc is automatically unary because it doesn't access `Y`.
  ;;
  src = X

  ;; Return if nothing to do. ;;
  (src <= 1) ? ret.(src)

  mod = 0
  out = 1
  ind = 2

  while.(ind <= src).(
    ;;
    Reassignment with inline list destructuring.
    The reassignment operator `=:` is provisional / TBD.
    ;;
    [mod out] =: [out (mod + out)]
    ind =+ 1
  )
  out
)

;;
Public interface which takes one number `X`
and calls an internal implementation.
;;
fib = fn.(fib_internal.[X 0 1])

;; Might end up with arrow procs too. ;;
fib = num -> fib_internal.[num 0 1]

;; Uses recursion and assumes TCO (tail-call optimization). ;;
fib_internal = fn.{
  X [3 Uint]
  Z Uint
  Z (
    ;; destructure ;;
    [A B C] = X
    (A <= 1) ? A : fib_internal.[(A - 1) C (B + C)]
  )

  ;;
  Since TCO is error-prone, the language may provide a pragma for validating
  that a given proc is TCO-compatible. See [#pragmas] in the lang doc.
  ;;
  :: tco
}

fib_internal :: tco
fib_internal = fn.[
  [3 Uint] -> Uint
  [A B C] = X
  (A <= 1) ? A : fib_internal.[(A - 1) C (B + C)]
]

;;
## Conditional compilation

Essential for targeting different platforms with the same code.

Syntax is TBD.
;;
when.(compiler.target_os == `linux`).(
  do_one_thing
)
when.(compiler.target_os == `xnu`).(
  do_another_thing
)
compiler.case.(compiler.target_os).{
  `linux`  do_one_thing
  `darwin` do_another_thing
}

;;
## Subclasses and methods

Our language is not object-oriented, and our proc overloading makes methods
mostly unnecessary. That said, interop with C++ and JS requires a way to
declare subclasses with methods. This should be implementable entirely in
standard library code without language-level support.

Syntax and semantics are TBD.
;;

;;
Example targeting JS/DOM interop. Custom DOM elements have special lifecycle
callbacks, which must be declared as methods on an element subclass.
We might be able to do this with pragmas. Noisy but rarely needed.
;;

Some_elem = HTMLElement.subclass

connectedCallback :: Some_elem.method
connectedCallback = fn.(;; Initialize. ;;)

disconnectedCallback :: Some_elem.method
disconnectedCallback = fn.(;; Deinitialize. ;;)

;; Library code should also be able to invent more specialized "syntax": ;;
Some_elem = HTMLElement.subclass.{
  prototype {
    connectedCallback    fn.(;; Initialize. ;;)
    disconnectedCallback fn.(;; Deinitialize. ;;)
  }
}

;; Non-callbacks don't need any of that, and would be regular procs: ;;
init = fn.{
  X Some_elem
  Y {
    id  Str
    cls Str
  }
  Z (
    X.id = id
    X.cls = cls
    X
  )
}

Some_elem.new.init.{id `some_id` cls `some_cls`}

;;
Custom DOM elements need registration. Web frameworks do this with decorators,
which correspond to our pragmas. It's actually possible to register implicitly,
so this is just for demonstration purposes.
;;
Some_elem :: custom_elem.`some-elem`

;;
## JS

When targeting JS, we need the ability to import JS code
and declare what's there.
;;
some_lib = import.{
  src  `./some_lib.mjs`
  type `js`
  sym {
    SOME_CONST Int
    proc0      Int -> Int
    proc1      [Int Str Bool] -> Dict
    proc2      {one Int two Str} -> {three Bool four List}

    ;;
    Alternative proc type syntax. This is probably preferred because
    `->` is difficult for syntax highlighters in complex cases.
    Spacing may or may not be required depending on how we handle this.
    ;;
    proc0 fn. Int. Int
    proc1 fn. [Int Str Bool]. Dict
    proc2 fn. {one Int two Str}. {three Bool four List}
  }
}

;; Optional: splurge the library into scope. ;;
some_lib.include

_ = SOME_CONST
_ = proc0.123
_ = proc1.[123 `str` true]

;; Destructure by listing field names. ;;
(three four) = proc2.{one 123 two `str`}

;; Destructure with alternative local names. ;;
{
  three local_var_0
  four  local_var_1
} = proc2.{one 123 two `str`}

;;
## Markup

Sample HTML/DOM markup code.

Procs such as `H.html` would return DOM nodes. In non-JS or non-browser
environments this would use a lightweight DOM shim.

The `html` module defines an anonymous generic proc `Element Props -> Element`
which takes any `Element` and a struct of properties for that element, applies
the properties, and returns the same element.

Similarly, it defines an anonymous `Node List -> Node` which takes a `Node` and
a `List` of child nodes, replaces the node's children with that list, and
returns the same `Node`. The `.[]` calls below invoke that proc. In essence,
any node is "callable" with a child list.

It also defines an anonymous `Node Str -> Node` which sets a node's text.
This makes any node "callable" with a string, resulting in terse but clear
markup below.
;;
H = import.`std:html`

H.html.{lang `en`}.[
  H.head.[
    H.meta.{charset `utf-8`}
    H.title.`sample_website`
    H.link.{rel `stylesheet` href `/main.css`}
  ]
  H.body.[
    H.p.`hello world!`
  ]
]

;;
Example of customizing the behavior of the renderer.
Since modules are structs and structs are modules,
we can define an inline "sub-module" with overrides.
;;
H = struct.(
  include.`std:html`

  ;;
  Overriding a proc should affect all procs using it.
  With this override, every value will be rendered in its "repr" form.
  ;;
  render_text = fn.(X.repr)
)

;;
Due to the override, text is now rendered with quotes,
like: `"hello_world"`.
;;
H.p.`hello_world`
