;;
## Hello world

Traditional:
;;
main = () -> log.`hello world!`

;;
## Fibonacci sequence

The function is defined below. This is how we call it:
;;
fib.42            ;; With a literal value. ;;
fib.(some_number) ;; With a named value. ;;

;;
Example definition.

Easiest to understand: a recursive version incompatible with tail-call
optimization. See below for a non-stack-overflowing version.
;;
fib = num -> (num <= 1)
  ? num
  ! fib.(num - 1) + fib.(num - 2)

;;
Procedural non-recursive version.
Translated from bot-generated Python.
Can probably be greatly simplified.
;;
fib = num -> (
  ;; Return if nothing to do. ;;
  (num <= 1) ? ret.(num)

  mut : mod = 0
  mut : out = 1
  mut : ind = 2

  while.(ind <= num).(
    ;; Reassignment with inline list destructuring. ;;
    [mod out] <- [out (mod + out)]
    ind       <- ind + 1
  )
  out
)

;;
Public interface which takes one number
and calls an internal implementation.
;;
pub : fib = num -> fib_internal.[num 0 1]

;; Uses recursion and assumes TCO (tail-call optimization). ;;
fib_internal = [A B C] ->
  (A <= 1)
  ? A
  ! fib_internal.[(A - 1) C (B + C)]

;;
With a type signature pragma, and a TCO pragma. Since TCO is error-prone,
the language may provide a pragma for validating that a given proc is
TCO-compatible. See [#pragmas] in the lang doc.
;;
(Uint.Arr.3 -> Uint) : tco :
fib_internal = [A B C] ->
  (A <= 1)
  ? A
  ! fib_internal.[(A - 1) C (B + C)]

;;
## Conditional compilation

Essential for targeting different platforms with the same code.

Syntax is TBD.
;;
(compiler.os == `linux`) & (compiler.arch = `x86`) #->
SYSCALL_READ = 3

(compiler.os == `linux`) & (compiler.arch = `x64`) #->
SYSCALL_READ = 0

(compiler.os == `linux`) & (compiler.arch = `arm64`) #->
SYSCALL_READ = 63 ;; ðŸ¤¯ ;;

;;
## Subclasses and methods

Our language is not object-oriented, and our proc overloading makes methods
mostly unnecessary. That said, interop with C++ and JS requires a way to
declare subclasses with methods. This should be implementable entirely in
standard library code without language-level support.

Syntax and semantics are TBD.
;;

;;
Example targeting JS/DOM interop. Custom DOM elements have special lifecycle
callbacks, which must be declared as methods on an element subclass.
We might be able to do this with pragmas. Noisy but rarely needed.
;;

Some_elem = HTMLElement.subclass

Some_elem.method :
connectedCallback = this -> <some_initialization>

Some_elem.method :
disconnectedCallback = this -> <some_deinitialization>

;; Library code should also be able to invent more specialized "syntax": ;;
Some_elem = HTMLElement.subclass.{
  prototype {
    connectedCallback    this -> <some_initialization>
    disconnectedCallback this -> <some_deinitialization>
  }
}

;; Non-callbacks don't need any of that, and would be regular procs: ;;
init = (this = Some_elem) -> {id = Str cls = Str} -> (
  this.id = id
  this.cls = cls
  this
)

Some_elem.init.{id = `some_id` cls = `some_cls`}

;;
Custom DOM elements need registration. Web frameworks do this with decorators,
which correspond to our pragmas. It's actually possible to register implicitly,
so this is just for demonstration purposes.
;;
custom_elem.`some-elem` :
Some_elem = <definition>

;;
## JS

When targeting JS, we need the ability to import JS code
and declare what's there.
;;
some_lib = import.{
  src  = `./some_lib.mjs`
  type = `js`
  decl = {
    SOME_CONST = Int
    proc0      = Int -> Int
    proc1      = [Int Str Bool] -> Dict
    proc2      = {one = Int two = Str} -> {three = Bool four = List}
  }
}

;; Optional: splurge the library into scope. ;;
some_lib.include

_ = SOME_CONST
_ = proc0.123
_ = proc1.[123 `str` true]

;; Destructure by listing field names. ;;
(three four) = proc2.{one = 123 two = `str`}

;; Destructure with alternative local names. ;;
{
  local_var_0 = three
  local_var_1 = four
} = proc2.{
  one = 123
  two = `str`
}

;;
## Markup

Sample HTML/DOM markup code.

Procs such as `H.html` would return DOM nodes. In non-JS or non-browser
environments this would use a lightweight DOM shim.

The `html` module defines an anonymous generic proc `Element Props -> Element`
which takes any `Element` and a struct of properties for that element, applies
the properties, and returns the same element.

Similarly, it defines an anonymous `Node List -> Node` which takes a `Node` and
a `List` of child nodes, replaces the node's children with that list, and
returns the same `Node`. The `.[]` calls below invoke that proc. In essence,
any node is "callable" with a child list.

It also defines an anonymous `Node Str -> Node` which sets a node's text.
This makes any node "callable" with a string, resulting in terse but clear
markup below.
;;
H = import.`std:html`

H.html.{lang = `en`}.[
  H.head.[
    H.meta.{charset = `utf-8`}
    H.title.`sample_website`
    H.link.{rel = `stylesheet` href = `/main.css`}
  ]
  H.body.[
    H.p.`hello world!`
  ]
]

;;
Example of customizing the behavior of the renderer.
Since modules are structs and structs are modules,
we can define an inline "sub-module" with overrides.
;;
H = struct.(
  include.`std:html`

  ;;
  Overriding a proc should affect all procs using it.
  With this override, every value will be rendered in its "repr" form.
  ;;
  render_text = val -> val.repr

  ;; Or maybe this: ;;
  render_text = repr
)

;;
Due to the override, text is now rendered with quotes,
like: `"hello_world"`.
;;
H.p.`hello_world`
