;;
This file tracks various minor ambiguities spotted in the lang drafts,
and solutions / disambiguations.
;;

;;
## Operator declarations

To implement operators, you have to actually declare them. We have two ways
of declaring stuff: procedural assignment and struct fields.

Operator-looking symbols without a dot on either side are always treated as
binary infix and combined with the expressions on both sides. This takes
priority over being in field name position, and over being in the LHS of
a declaration operator.

The ambiguity arises because we refuse to use separator characters
such as commas, we're newline-insensitive, and the only precedence
rule for binary infix is left associativity.

The provisional solution is to allow strings instead of symbols in all
declaration positions. It's been demonstrated to be acceptable in JS,
where names of class fields and methods can be declared with strings.
Syntax highlighters support those declarations just fine. However,
this raises the issue of how to access such fields later on. Operator
fields are accessed with symbols as usual, but what if someone wants
to use a field named `my awesome field` (with spaces)? For now, the
field would be inaccessible.

We don't consider this a gotcha because syntax highlighting makes this
obvious, as long as it's correctly implemented. Compiler can give clear
errors too.
;;

;; Not what it looks like. ;;
Person = struct.{
  Id    Uuid
  *     Named
  *     Timed
  email Str
}

;; This is what actually happens. ;;
Person = struct.{
  Id    Uuid * Named * Timed
  email Str
}

;; Workaround. ;;
Person = struct.{
  Id    Uuid
  `*`   Named
  `*`   Timed
  email Str
}

;; Not what it looks like. ;;
some_preceding_expression
+ = fn.(asm.i32_add.[X Y])

;; Becomes this and doesn't compile. ;;
some_preceding_expression + = fn.(asm.i32_add.[X Y])

;; Provisional solution. ;;
`+` = fn.(asm.i32_add.[X Y])

;;
## Groups vs tuples

Some parts of the draft accidentally assume the existence of tuple types which
would be instantiated with () in places where a tuple type is inferred. This
can be ambiguous with using () for grouping.

Since we encourage structs to keep APIs extensible, we'll probably just avoid
tuples in the type system, like Go did. They should however be implementable
in library code, for cases where tuples are best.
;;

;;
## Unary and binary calls

Our call syntax has what may seem like a built-in ambiguity in symbol chains.
The following could be seen as representing either an unary or a binary call:
;;
one.two.three

;;
However, at the data notation level, we disambiguate this
by splitting symbols at dots, turning into 2 unary calls:
;;
one .two .three

;;
Binary symbolic calls can be used by splitting in different places manually:
;;
one .two. three

;;
However, this creates a perverse incentive to manually overload each symbolic
binary proc with an unary variant which returns a curried unary proc, allowing
to call it without the preceding space. The following assumes that the current
scope has an unary proc `two` which can be called on `one` and returns an unary
proc which can be called on `three`:
;;
one.two. three

;;
This is very similar to auto-bound methods in Go and Python. Since it's such a
common use case, we might go ahead and make it built-in: for every binary proc,
the compiler auto-defines an unary currying variant. If this creates too many
naming conflicts, we would abandon the feature or make it opt-in.

The following code assumes that `map` was only defined as a binary proc,
but the compiler auto-derived an unary version.
;;
src = [10 20 30]
out = src.map. fn.(X * 2)  ;; curried unary ;;
out = src .map. fn.(X * 2) ;; actual binary ;;
