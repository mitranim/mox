;;
This file tracks various minor ambiguities spotted in the lang drafts,
and solutions / disambiguations.
;;

;;
## (Solved) Operator declarations

Operators can be "escaped" by "grouping":
;;
(*) = 123

Person = struct.{
  id    = Uuid
  (*)   = Named ;; splurge another type ;;
  (*)   = Timed ;; splurge another type ;;
  email = Str
}

;;
## Groups vs tuples

Some parts of the draft accidentally assume the existence of tuple types which
would be instantiated with () in places where a tuple type is inferred. This
can be ambiguous with using () for grouping.

Since we encourage structs to keep APIs extensible, we'll probably just avoid
tuples in the type system, like Go did. They should however be implementable
in library code, for cases where tuples are best.
;;

;;
## (Solved) Unary and binary calls

All of the following used to be different from each other:
;;
one.two.three   ;; postfix unary, postfix unary ;;
one. two.three  ;; prefix unary, postfix unary ;;
one. two. three ;; prefix unary, prefix unary;;
one .two. three ;; binary ;;

;;
Now all procs are unary, dots are split off, and all of the above
are parsed and interpreted identically to the following:
;;
(one . two) . three

;; Inherently "binary" procs like `map` are defined as `A -> B -> C`: ;;
map = list -> fun -> (
  buf = list.type.alloc.(list.len)
  list.iter.(val ind).(
    buf.ind.& = val.fun
  )
  buf
)

;; Usage: ;;
src = [10 20 30]
out = src.map.(val -> val * 2)

;; Where `src.map` actually returns a "curried" closure: ;;
out = (src.map).(val -> val * 2)

;;
Unlike Haskell, we can't define this shorthand auto-currying syntax:

  fun one two three = another_fun one two three

By design, our call notation is incompatible with this.
Homogeneous procs should take a list, and heterogeneous
procs should take a struct (named parameters):

  proc = vals -> vals.another_proc
  proc = [A B C] -> A + B + C
  proc = {arg0 = Type0 arg1 = Type1} -> do_stuff

Our call notation automatically discourages long-arity procs
such as `Int -> Int -> Int -> Int -> Int` because the calls
are horrible to type and read:
;;
mul4.10.20.30.40
mul4.(one).(two).(three).(four)

;; Just pass a list: ;;
*.[10 20 30 40]
*.[one two three four]

;;
## Proc types vs proc implementations

First, a comparison. Haskell uses chains of `->` for type signatures _and_
inline functions, and disambiguates them in multiple orthogonal ways.

  λ a b c -> a + b + c -- inline function; may not occur in type positions
  Int -> Int -> Int    -- can only occur in type positions
  Int -> (Int -> Int)  -- implicit right-association
  a -> b -> c -> d     -- can only occur in type positions
  a -> (b -> (c -> d)) -- implicit right-association

`λ` in Haskell is basically a keyword, a parser special case.

We'd like to use `->` for proc types _and_ implementations.
We have no special parser rules for proc types and values.
Both are created by immediate procs invoked with regular
proc call syntax. They need to be disambiguated contextually.
;;

;;
We have to make `->` right-associative. This also means we can make arbitrary
operators right-associative. Incidentally, this now includes `:`.
;;
Int -> Int -> Int -> Int
Int -> (Int -> (Int -> Int))

;;
Proc types do not contain parameter names. If the LHS of `->` denotes a type,
the RHS must also denote a type, and the result is a proc type.
;;
Int -> Int
Int -> Int -> Int

;; LHS of `->` in proc implementations must contain parameter names: ;;
one     -> one     ;; generic identity function ;;
Int:one -> Int:one ;; specialized identity function ;;
one     -> two     ;; `one` is ignored, `two` must be in scope ;;
Int:one -> Int:two ;; `one` is ignored, `two` must be in scope ;;
